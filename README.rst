🦾 **django-migration-extensions** includes a few more batteries for *Django Migrations*


Table of Contents
#################

.. contents::
   :local:


Installation
============

Simply put ``django_migration_extensions`` in your ``INSTALLED_APPS``


Strategies for Handling Migration Conflicts
===========================================

Django uses a very safe approach in terms of handling migration conflicts: it will not let more than one person
in your team to make **any** changes to an app that requires a migration, without having someone to merge the
conflicts manually. This can turn in a bottleneck when you have a large team making multiple changes throughout
the day.

Let's say you have the following scenario:

1. 🙋‍♂️ and 💁‍♀️ are working on changes to the same Django app called **library**
2. 🤷‍♀️ got her PR approved, and her changes got into **master**, adding a new field: ``Author.bio``
3. Finally, 💁‍♂️ also got his new model ``Shelf`` in the **master** branch, but suddenly: 💥 **BUILD FAILED** 🤦‍♂️

.. code::

  CommandError: Conflicting migrations detected; multiple leaf nodes in the
  migration graph: (0002_author_bio, 0002_shelf in library)
  
  To fix them run 'python manage.py makemigrations --merge'
  
Not that bad, 🙍‍♂️ were able to fix the issue by creating another PR with the merge fix.

But now imagine you have a quite large team, how could we improve this experience? *Keep reading...*


ModelDetectConflictStrategy
---------------------------

Installation
////////////

In your settings file, add:

.. code:: python

   MIGRATION_CONFLICT_DETECTOR_STRATEGY = "django_migration_extensions.strategies.ModelDetectConflictStrategy"
   

The ``ModelDetectConflictStrategy`` strategy leverages the built-in conflict detector in Django Migrations, that does not
accept multiple leaf nodes in the migration graph, by **allowing multiple leaf nodes unless they change the same model**.

In the scenario above, 🙍‍♂️ and 🤷‍♀️ wouldn't have any conflicts, since they were working on the same app but in
different models.

This strategy is not a silver-bullet, it will still give you conflicts if more than one person changes the same model.
In the other hand, it will reduce the number of conflicts considerably if you have more models in your codebase.

But even when you have more than one person changing the same model, we can still do a little more! *Keep reading...*


Manifest file
-------------

Strategies do a little more than leveraging the Django Migration's conflict detector! They also provide a little tool
that will enable you to catch conflicts before they break your master branch: **The Manifest file**

A Manifest file is automatically generated by a strategy after a new migration is created. The Manifest is carefully
crafted with only one purpose: **force conflicts to happen in your DVCS** (eg. git). Yeah we're forcing conflicts to
happen, this way your DVCS will try to tell you something isn't good with your migrations, before you break your master
branch. Let's take a look on how a Manifest File looks like:

.. code:: python

    {
        "admin.logentry": "0001_initial",
        "app.author": "0007_remove_author_state",
        "app.book": "0005_auto_20200217_1529",
        "app.shelf": "0005_auto_20200217_1529"
    }

This is a small example of a Manifest file generated automatically by the ``ModelDetectConflictStrategy`` strategy. Think
about the following scenario:

1. 🙎‍♂️ adds a new field to the ``Book`` model in his branch: ``feat/add_book_field``
2. In the meantime, 🙆‍♀️ is also working on another branch, changing the same model (I can smell conflicts)
3. 🙅‍♂️ was faster now and got his changes merged into **master** ✓ This is how the manifest file looks now:

.. code:: python

    {
        "admin.logentry": "0001_initial",
        "app.author": "0007_remove_author_state",
        "app.book": "0008_add_book_field",   # 👀
        "app.shelf": "0005_auto_20200217_1529"
    }

4. 🙍‍♀️ finished her changes, but     now that she ran the ``makemigrations`` command, GitHub is saying she got conflicts
to resolve! She is trying to modify a line that has been modified in **master** after she pulled last time.

.. code:: python

    {
        "admin.logentry": "0001_initial",
        "app.author": "0007_remove_author_state",
    <<<<<<< HEAD
        "app.book": "0008_add_book_field",   # 👀 💁‍♂️
    =======
        "app.book": "0008_add_another_book_field",   # 👀 🤦‍♀️
    >>>>>>> master
        "app.shelf": "0005_auto_20200217_1529"
    }

5. 🙋‍♀️ were able to fix the conflicts by just pulling from **master** and redoing her migration. Let's see how the
manifest file looks like now:

.. code:: python

    {
        "admin.logentry": "0001_initial",
        "app.author": "0007_remove_author_state",
        "app.book": "0008_add_another_book_field",   # 👏
        "app.shelf": "0005_auto_20200217_1529"
    }
